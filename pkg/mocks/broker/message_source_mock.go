// Code generated by MockGen. DO NOT EDIT.
// Source: .//broker/message_source.go

// Package broker is a generated GoMock package.
package broker

import (
	context "context"
	reflect "reflect"

	packet "github.com/BAN1ce/skyTree/pkg/packet"
	gomock "github.com/golang/mock/gomock"
)

// MockMessageSource is a mock of MessageSource interface.
type MockMessageSource struct {
	ctrl     *gomock.Controller
	recorder *MockMessageSourceMockRecorder
}

// MockMessageSourceMockRecorder is the mock recorder for MockMessageSource.
type MockMessageSourceMockRecorder struct {
	mock *MockMessageSource
}

// NewMockMessageSource creates a new mock instance.
func NewMockMessageSource(ctrl *gomock.Controller) *MockMessageSource {
	mock := &MockMessageSource{ctrl: ctrl}
	mock.recorder = &MockMessageSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessageSource) EXPECT() *MockMessageSourceMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockMessageSource) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockMessageSourceMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockMessageSource)(nil).Close))
}

// ListenMessage mocks base method.
func (m *MockMessageSource) ListenMessage(ctx context.Context) (<-chan *packet.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListenMessage", ctx)
	ret0, _ := ret[0].(<-chan *packet.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListenMessage indicates an expected call of ListenMessage.
func (mr *MockMessageSourceMockRecorder) ListenMessage(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListenMessage", reflect.TypeOf((*MockMessageSource)(nil).ListenMessage), ctx)
}

// NextMessages mocks base method.
func (m *MockMessageSource) NextMessages(ctx context.Context, n int, startMessageID string, include bool) ([]*packet.Message, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NextMessages", ctx, n, startMessageID)
	ret0, _ := ret[0].([]*packet.Message)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// NextMessages indicates an expected call of NextMessages.
func (mr *MockMessageSourceMockRecorder) NextMessages(ctx, n, startMessageID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NextMessages", reflect.TypeOf((*MockMessageSource)(nil).NextMessages), ctx, n, startMessageID)
}

// MockStreamSource is a mock of StreamSource interface.
type MockStreamSource struct {
	ctrl     *gomock.Controller
	recorder *MockStreamSourceMockRecorder
}

// MockStreamSourceMockRecorder is the mock recorder for MockStreamSource.
type MockStreamSourceMockRecorder struct {
	mock *MockStreamSource
}

// NewMockStreamSource creates a new mock instance.
func NewMockStreamSource(ctrl *gomock.Controller) *MockStreamSource {
	mock := &MockStreamSource{ctrl: ctrl}
	mock.recorder = &MockStreamSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStreamSource) EXPECT() *MockStreamSourceMockRecorder {
	return m.recorder
}

// ListenMessage mocks base method.
func (m *MockStreamSource) ListenMessage(ctx context.Context) (<-chan *packet.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListenMessage", ctx)
	ret0, _ := ret[0].(<-chan *packet.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListenMessage indicates an expected call of ListenMessage.
func (mr *MockStreamSourceMockRecorder) ListenMessage(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListenMessage", reflect.TypeOf((*MockStreamSource)(nil).ListenMessage), ctx)
}
